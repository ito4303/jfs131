---
title: "植生被度階級データの<br />モデリング"
author: "伊東宏樹"
date: "2020-03-27"
institute: "森林総合研究所北海道支所"
output:
  revealjs::revealjs_presentation:
    theme: white
    transition: slide
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(extraDistr)
library(ggplot2)
library(ggthemes)
library(rstan)
library(cmdstanr)
Sys.setenv(PATH = "/usr/bin:/bin")
set_cmdstan_path("/usr/local/cmdstan")
library(bayesplot)
```

# はじめに

## 被度階級データ

- 被度（調査面積に対する対象植物の被覆度）は、もともとは0〜1の範囲の連続値。
- 実際には、{'+', '0', '1', '2', '3', '4', '5'}といった階級データとして記録されることが多い。
- また、測定値は目視で決められることが多い。

## 被度階級データの問題点

- 順序尺度データなので、数値的な取り扱いが簡単ではない。
- 測定誤差の問題。

## 被度（連続値）のモデリング

0〜1の連続値をとるので、ベータ分布にあてはめるのは自然な発想。

$$
y \sim \mathrm{Beta}(\alpha, \beta)
$$

<p style="height:1em;"></p>

平均$\mu$を使ったパラメータ化

$$
y \sim \mathrm{Beta}\left(\frac{\mu}{\delta}-\mu,\frac{(1-\mu)(1-\delta)}{\delta}\right)
$$

## ベータ分布(mu=0.6のとき) {#beta_distribution}

```{r plot_beta_distribution, echo=FALSE, warning=FALSE}
p <- 0.6
delta = c(0.001, 0.01, 0.1, 0.2, 0.4)
a <- p / delta - p
b <- (1 - p) * (1 - delta) / delta
x <- rep(seq(0.001, 1 - 0.001, length = 300), length(delta))
y <- matrix(0, ncol = length(delta), nrow = length(x))
for (d in seq_along(delta))
  y[, d] <- (sapply(seq_along(x), function(i) dbeta(x[i], a[d], b[d])))

df <- data.frame(Cover = x,
                 Density = c(y),
                 delta = factor(rep(delta, each = length(x))))
colors <- colorblind_pal()(8)[c(7, 6, 3, 2, 4)]
ggplot(df, aes(x = Cover, y = Density, color = delta)) +
  geom_line(size = 2, alpha = 0.9) +
  scale_color_manual(values = colors) +
#  annotate("text", x = 0, y = 24, hjust = 0,
#           label = "mu=0.6", color = "black") +
  annotate("text", x = 0.625, y = 20, hjust = 0, size = 6,
           label = bquote(delta == .(delta[1])), color = colors[1]) +
  annotate("text", x = 0.65, y = 6.5, hjust = 0, size = 6,
           label = bquote(delta == .(delta[2])), color = colors[2]) +
  annotate("text", x = 0.68, y = 3.2, hjust = 0, size = 6,
           label = bquote(delta == .(delta[3])), color = colors[3]) +
  annotate("text", x = 0.8, y = 2.35, hjust = 0, size = 6,
           label = bquote(delta == .(delta[4])), color = colors[4]) +
  annotate("text", x = 1, y = 10, hjust = 1, size = 6,
           label = bquote(delta == .(delta[5])), color = colors[5]) +
  theme_gray(base_family = "Helvetica", base_size = 24) +
  theme(legend.position = "none")
```

## Changing delta

```{r gen_sim_data, include=FALSE}
cover_prob <- function(cover, cut_points, a, b) {
  n <- length(cut_points)
  pr <- rep(0, n + 1)
  pr[1] <- pbeta(cut_points[1], a, b)
  for (k in 2:n)
    pr[k] <- pbeta(cut_points[k], a, b) -
             pbeta(cut_points[k - 1], a, b)
  pr[n + 1] <- 1 - pbeta(cut_points[n], a, b)
  return(pr)
}

sim_cover_prob <- function(delta = c(0.001, 0.01, 0.05, 0.1),
                           cut_points = c(0.01, 0.1, 0.25, 0.5, 0.75)) {
  # delta: intra-quadrat correlation in Damgaard (2014)
  #        also can be regarded as uncertainty in classification
  # cut_points : cut points of the cover classes

  n <- length(cut_points)
  nk <- length(cut_points)
  q <- seq(0.0001, 1 - 0.0001, length = 300)
  p <- sapply(delta, function(d) {
    a <- q / d - q
    b <- (1 - q) * (1 - d) / d
    pr <- sapply(seq_along(q),
                 function(i) cover_prob(q[i], cut_points, a[i], b[i]))
  })
  df <- data.frame(delta = rep(paste0("δ=", delta), each = length(q) * (nk + 1)),
                   Cover = rep(rep(q, each = nk + 1), length(delta)),
                   Probability = c(p),
                   Class = factor(rep(rep(1:(nk + 1), length(q)), length(delta))))
  plt <- ggplot(df) +
    geom_vline(xintercept = cut_points, color = "red", size = 0.33, linetype = 2) +
    geom_line(aes(x = Cover, y = Probability, color = Class), size = 0.67) +
    scale_color_manual(values = colorblind_pal()(8)[c(1, 2, 3, 4, 6, 7)]) +
    facet_wrap(~delta) +
    theme_bw()
  print(plt)
}
```

## Classes

Class definition

1: 0–0.01 (including 0), 2: 0.01–0.1, 3: 0.1–0.25, 4: 0.25–0.5, 5: 0.5–0.75, 6: 0.75–1


## $\delta$=0.001
```{r delta=0.001, echo=FALSE}
sim_cover_prob(delta = 0.001)
```

## $\delta$=0.01
```{r delta=0.01, echo=FALSE}
sim_cover_prob(delta = 0.01)
```

## $\delta$=0.05
```{r delta=0.05, echo=FALSE}
sim_cover_prob(delta = 0.05)
```

## $\delta$=0.1
```{r delta=0.1, echo=FALSE}
sim_cover_prob(delta = 0.1)
```

## $\delta$=0.2
```{r delta=0.2, echo=FALSE}
sim_cover_prob(delta = 0.2)
```

## $\delta$=0.4
```{r delta=0.4, echo=FALSE}
sim_cover_prob(delta = 0.4)
```

# Modeling

## Simulated data

```{r sim1_datagen, include=FALSE}
cover_class <- function(q, delta = 0.1, N = 1,
                        cp = c(0.01, 0.1, 0.25, 0.5, 0.75)) {
  nk <- length(cp)
  pr <- rep(0, nk + 1)
  a <- q / delta - q
  b <- (1 - q) * (1 - delta) / delta
  pr[1] <- pbeta(cp[1], a, b)
  for (k in 2:nk)
    pr[k] <- pbeta(cp[k], a, b) - pbeta(cp[k - 1], a, b)
  pr[nk + 1] <- 1 - pbeta(cp[nk], a, b)
  rcat(N, pr)
}


N <- 10
k <- c(0.01, 0.1, 0.25, 0.5, 0.75)
p <- 0.6
delta <- 0.05

set.seed(1234)
y <- cover_class(p, delta, N)
```

Data

- true cover = 0.6
- set delta = 0.05
- 10 times measurements

```{r print_sim1, echo=FALSE}
print(y)
```

## Stan code 1 (functions block)

```
functions {
  real coverclass_lpmf(int Y, vector CP, real a, real b) {
    int n_cls;
    real gamma;

    n_cls = num_elements(CP) + 1;
    if (Y <= 1) {  // 0 or 1
      gamma =  inc_beta(a, b, CP[1]);
    } else if(Y >= 2 && Y < n_cls) {
      gamma = inc_beta(a, b, CP[Y])
              - inc_beta(a, b, CP[Y - 1]);
    } else {
      gamma = 1 - inc_beta(a, b, CP[n_cls - 1]);
    }
    return bernoulli_lpmf(1 | gamma);
  }
}
```

## Stan code 2 (model block)

```
model {
  // Observation model
  {
    real a = p / delta - p;
    real b = (1 - p) * (1 - delta) / delta;

    for (n in 1:N)
      Y[n] ~ coverclass(CP, a, b);
  }
}
```

In `transformed parameters` block,

`p = inv_logit(beta + beta_x * x + ...)`

## Fit to the model

```{r sim1_fit, include=FALSE, cache=TRUE}
results_file <- "fit_sim1.RData"
if (file.exists(results_file)) {
  load(results_file)
} else {
  data <- list(N_cls = length(k) + 1,
               N = N,
               Y = y,
               CP = k)
  model <- cmdstan_model("cover.stan")
  fit <- model$sample(data = data,
                      num_chains = 4, num_cores = 4,
                      num_samples = 1000, num_warmup = 1000)
  fit_sim1 <- rstan::read_stan_csv(fit$output_files())
  save(fit_sim1, file = results_file)
}
```

## Posterior summary

```{r sim1_summary}
print(fit_sim1, pars = c("p", "delta"))
```

## Posterior predictive check

```{r sim1_ppc, echo=FALSE}
yrep <-  extract(fit_sim1, pars = "yrep")[["yrep"]]
pp_check(y, yrep, ppc_rootogram)
```

## Model with an explanatory variable

```{r cov1_datagen}
set.seed(1234)
N <- 50
R <- 2
k <- c(0.01, 0.1, 0.25, 0.5, 0.75)
x <- runif(N, 0, 1)
logit_p <- -5 + 5 * x + rnorm(N, 0, 0.5)
p <- 1 / (1 + exp(-logit_p))
delta <- 0.1
y <- matrix(0, nrow = N, ncol = R)
for (n in 1:N)
  for (r in 1:R)
    y[n, r] <- cover_class(p[n], delta)
ggplot(data.frame(x = rep(x, R), y = c(y),
                  rep = factor(rep(1:R, each = N)))) +
  geom_jitter(aes(x = x, y = y, color = rep), size = 2, alpha = 0.8,
              width = 0, height = 0.05) +
  scale_y_discrete(name = "Class", limits = 1:6, breaks = as.character(1:6))
```

<!-- Fitting -->

```{r cov1_fit, include=FALSE, cache=TRUE}
results_file <- "fit_cov1.RData"
if (file.exists(results_file)) {
  load(results_file)
} else {
  data <- list(N_cls = length(k) + 1,
               N = N,
               R = R,
               X = x,
               Y = y,
               CP = k)
  model <- cmdstan_model("cover2.stan")
  fit <- model$sample(data = data,
                      num_chains = 4, num_cores = 4,
                      num_samples = 1000, num_warmup = 1000)
  fit$cmdstan_diagnose()
  fit_cov1 <- rstan::read_stan_csv(fit$output_files())
  save(fit_cov1, file = results_file)
}
```

# Results

```{r}
print(fit_cov1, pars = c("delta", "beta", "sigma"))
```


# PPC

```{r}
yrep <-  extract(fit_cov1, pars = "yrep")[["yrep"]]
pp_check(y[, 1], yrep, ppc_rootogram)
pp_check(y[, 2], yrep, ppc_rootogram)
```

## Zero-inflation

Class definition in this model

0: 0, 
1: 0–0.01 (excluding 0), 2: 0.01–0.1, 3: 0.1–0.25, 4: 0.25–0.5, 5: 0.5–0.75, 6: 0.75–1

Constant cover for all quadrats excluding 0

```{r zi_datagen, echo=FALSE}
set.seed(1234)
N <- 50
R <- 2
k <- c(0.01, 0.1, 0.25, 0.5, 0.75)
x <- runif(N, 0, 1)
logit_p <- -5 + 5 * x + rnorm(N, 0, 0.5)
p <- 1 / (1 + exp(-logit_p))
delta <- 0.1
omega <- 0.7  # proportion on non-zero
psi <- 0.9    # detection prob.

y <- matrix(0, nrow = N, ncol = R)
for (n in 1:N) {
  if (runif(1, 0, 1) < omega) { # present
    for (r in 1:R)
      y[n, r] <- cover_class(p[n], delta)
      if (y[n, r] == 1 & runif(1, 0, 1) > psi)
        y[n, r] <- 0
  }
}
```

## View data

```{r zi_view, echo=FALSE}
ggplot(data.frame(x = rep(x, R), y = c(y),
                  rep = factor(rep(1:R, each = N)))) +
  geom_jitter(aes(x = x, y = y, color = rep), size = 2, alpha = 0.8,
              width = 0, height = 0.1) +
  scale_y_discrete(name = "Class", limits = 0:6, breaks = as.character(0:6))
```

## Stan code

```
model {
  // Observation model
  for (n in 1:N) {
    real a = p[n] / delta - p[n];
    real b = (1 - p[n]) * (1 - delta) / delta;

    if (sum(Y[n]) == 0) { // Y[n]==0 for all n
      real lp[2];
      
      lp[1] = bernoulli_lpmf(0 | omega);
      lp[2] = bernoulli_lpmf(1 | omega)
              + coverclass_lpmf(1 | CP, a, b) * R
              + bernoulli_lpmf(0 | psi) * R;
      target += log_sum_exp(lp);
    } else {
      for (r in 1:R) {
        if (Y[n, r] == 0) {
          target += bernoulli_lpmf(1 | omega)
                    + coverclass_lpmf(1 | CP, a, b)
                    + bernoulli_lpmf(0 | psi);
        } else if (Y[n, r] == 1) {
          target += bernoulli_lpmf(1 | omega)
                    + coverclass_lpmf(1 | CP, a, b)
                    + bernoulli_lpmf(1 | psi);
        } else {
          target += bernoulli_lpmf(1 | omega)
                    + coverclass_lpmf(Y[n, r] | CP, a, b);
        }
      }
    }
  }
  // System
  err ~ std_normal();
  sigma ~ normal(0, 5);
}
```

<!-- Fitting -->

```{r zi_fitting, include=FALSE, cache=TRUE}
results_file <- "fit_zi.RData"
if (file.exists(results_file)) {
  load(results_file)
} else {
  data <- list(N_cls = length(k) + 1,
               N = N,
               R = R,
               X = x,
               Y = y,
               CP = k)
  model <- cmdstan_model("zicover.stan")
  fit <- model$sample(data = data,
                      num_chains = 4, num_cores = 4,
                      num_samples = 1000, num_warmup = 1000)
  fit$cmdstan_diagnose()
  fit_zi <- rstan::read_stan_csv(fit$output_files())
  save(fit_zi, file = results_file)
}
```

## Posterior summary

```{r}
print(fit_zi, pars = c("delta", "omega", "psi", "beta", "sigma"))
```

```{r}
yrep <-  extract(fit_zi, pars = "yrep")[["yrep"]]
pp_check(y[, 1], yrep, ppc_rootogram)
pp_check(y[, 2], yrep, ppc_rootogram)
```


## CAR

```{r, include=FALSE}
library(geoR)

set.seed(123)
nx <- 10
ny <- 10
fld1 <- grf(nx * ny, grid = "reg", nx = nx, ny = ny, cov.pars=c(0.2, 1 / nx))
df <- data.frame(x = fld1$coords[, "x"], y = fld1$coords[, "y"],
                 p = 1 / exp(1 + exp(-fld1$data)))
df$class <- sapply(df$p, function(p) cover_class(p, delta = 0.01))
df$class <- factor(df$class)
#mean(df$p)
#print(df$class)
```

## Proportion

```{r car_map, echo=FALSE}
ggplot(df, aes(x = x, y = y, fill = p)) +
  geom_bin2d(stat = "identity") +
  coord_fixed()
```

## Class

```{r car_class_map, echo=FALSE}
ggplot(df, aes(x = x, y = y, fill = class)) +
  geom_bin2d(stat = "identity") +
  coord_fixed()
```

## Stan model

Exact sparse CAR models in Stan by Max Joseph

https://mc-stan.org/users/documentation/case-studies/mbjoseph-CARStan.html

```
model {
  // Spatial random effects
  phi ~ sparse_iar(tau, W_sparse, D_sparse, lambda, N, W_n);

  // Observation model
  for (n in 1:N) {
    real a = p[n] / delta - p[n];
    real b = (1 - p[n]) * (1 - delta) / delta;

    Y[n] ~ coverclass(CP, a, b);
  }

  // Priors
  tau ~ gamma(2, 2);
}
```


## Fit

```{r car_stan, include=FALSE, cache=TRUE}
# Adjacency matrix
w <- matrix(0, ncol = nx * ny, nrow = nx * ny)
for (i in 1:(nx * ny)) {
  x <- (i - 1) %% nx + 1    # x first
  y <- (i - 1) %/% nx + 1   # y second
  if (x > 1)
    w[i, (y - 1) * nx + x - 1] <- 1 # [x - 1, y]
  if (x < nx)
    w[i, (y - 1) * nx + x + 1] <- 1 # [x + 1, y]
  if (y > 1)
    w[i, (y - 2) * nx + x] <- 1     # [x, y - 1]
  if (y < ny)
    w[i, y * nx + x] <- 1           # [x, y + 1]
}

data <- list(N_cls = length(k) + 1,
             N = nrow(df),
             Y = df$class,
             CP = k,
             W = w,
             W_n = sum(w) / 2)
model <- cmdstan_model("carcover.stan")
fit <- model$sample(data = data,
                    num_chains = 4, num_cores = 4,
                    num_samples = 4000, num_warmup = 4000,
                    refresh = 400)
fit4 <- rstan::read_stan_csv(fit$output_files())
```

## Results

```{r car_reults}
print(fit4, pars = c("delta", "tau"))
#print(fit4, pars = c("p"))
#stan_trace(fit4, pars = c("delta", "tau"))
#yrep <-  extract(fit4, pars = "yrep")[["yrep"]]
#pp_check(df$class, yrep, ppc_rootogram) +
#  ggplot2::scale_x_discrete(name = "Class", limits = as.character(1:6))
```

## Show results

```{r car_result_map, echo=FALSE}
df$estimate <- get_posterior_mean(fit4, pars = "p")[, "mean-all chains"]
ggplot(df, aes(x = x, y = y, fill = estimate)) +
  geom_bin2d(stat = "identity") +
  coord_fixed()
```

## True vs. Estimated Cover

```{r car_comp, echo=FALSE}
ggplot(df, aes(x = p, y = estimate)) +
  geom_point() +
  xlim(0, 0.3) + ylim(0, 0.3) +
  labs(x = "True cover", y = "Estimated cover") +
  geom_abline(slope = 1) +
  coord_fixed()
```

# Summary

## Cover class data

- Modeling
